% !TEX root=../../report.tex

\Section[asp_basics]{ASP Basics}
Das ASP .NET Framework wurde kombiniert mit den Frameworks \gls{mvc} Core, Identity Core, Razor Core und \gls{ef} und daraus entstand das \gls{asp} Framework. Das EventManager System benutzt alle diese Komponenten außer Razor Core. Dies sind alles Web Frameworks, die auf dem \gls{owin} aufbauen. \gls{owin} selbst ist keine Implementierung, sondern eine Spezifikation. Diese Spezifikation hilft dabei, eine einfache, austauschbare, und damit entkoppelte Architektur zu gestalten. \gls{owin} definiert unter anderem die sogenannte Middleware Pipeline. Middleware ist der von \gls{owin} definierte Begriff für austauschbare Codebausteine. \gls{owin} spezifiziert folgende Signatur \lstcode{Func<IDictionary<string, object>, Task>}. Eine Middleware kann die Form einer Klasse oder auch eines Delegates haben. \gls{asp} erkennt mithilfe von Reflection, ob eine Klasse eine Methode implementiert, welche der Middlewaresignatur entspricht. Um nun einen \gls{http}-Request bearbeiten zu können, wird eine Middleware Pipeline benötigt. Diese wird am Anfang des Applikationslebenszyklus einmalig aufgebaut und danach von jedem Request durchlaufen. \cite{owinKatana}

\Subsubsection{Die \lstcode{Program} und \lstcode{Startup} Klassen}

In der \lstcode{Program} Klasse befindet sich die \lstcode{Main} Methode. In dieser Methode wird der \lstcode{WebHost} gebaut und gestartet. Der \lstcode{WebHost} ist der zugrunde liegende Webserver. Anders als andere Webprojekte, ist \gls{asp} mit einem eigenen Webserver namens Kestrel ausgestattet. Dieser Webserver ist ausreichend, um die Webseite zu hosten, ist jedoch eher minimalistisch gehalten. Er wird oftmals in Kombination mit anderen Webservern wie \zB IIS, Nginx oder Apache eingesetzt \cite{kestrel}. Hier kann man, wie in \myautoref{lst:program.cs} zu sehen, die Konfiguration anpassen, die \lstcode{Startup} Klasse spezifizieren und weitere Kestrel-spezifische Anpassungen vornehmen.

\file{program.cs}{Beispielkonfiguration des Kestrel Webservers.}{nc_csharp}

Wie bereits erwähnt, wird eine \lstcode{Startup} Klasse konfiguriert. Diese Klasse ist als \enquote{Composition Root} zu sehen \cite{compRoot}. Sie besteht aus drei Komponenten: dem Konstruktor, der \lstcode{ConfigureServices} und der \lstcode{Configure} Methode. Der Konstruktor bekommt ein Objekt übergeben, welches das \lstcode{IHostingEnvironment} Interface implementiert. Mithilfe des \lstcode{IHostingEnvironment} lässt sich ein Konfigurationsobjekt erstellen. Dieses beinhaltet den ContentRootPath und die Umgebungsvariablen. Außerdem werden innerhalb des Konfigurationsobjektes \lstcode{IOptions<>} Objekte erzeugt, welche die Einstellungen der \enquote{appsettings.json} Dateien enthalten.

Die \lstcode{ConfigureServices} Methode wird genutzt, um einen \gls{di} Container zu konfigurieren. \gls{asp} nutzt standardmäßig das AutoFac Framework. Dieses ist jedoch nochmals durch einige Interfaces abstrahiert. So wird ein \lstcode{IServiceCollection} Interface an die Methode übergeben und das \lstcode{IServiceProvider} Interface wird oft vom Framework selbst genutzt. Diese beiden Interfaces funktionieren analog zu ContainerBuilder und Container, wie in \myref{sec:aspDi} beschrieben. Obwohl \gls{asp} unterliegend das AutoFac Framework nutzt, sind einige AutoFac Funktionalitäten durch die zusätzlichen Interfaces \enquote{wegabstrahiert}. \gls{asp} hat den Vorteil, dass man es mit jedem beliebigen \gls{di} Framework nutzen kann. Hierfür muss die Signatur der \lstcode{ConfigureServices} Methode angepasst werden. Die Standardsignatur \lstcode{public void ConfigureServices(IService\-Collection services)} wird nun auf \lstcode{public IServiceProvider Config\-ureServices(IService\-Collection services)} geändert. \gls{asp} erkennt anhand von Reflection, was der Entwickler beabsichtigt. Im Falle, dass der Rückgabetyp nicht mehr \lstcode{void}, sondern \lstcode{IServiceProvider} ist, soll also ein spezieller \gls{di} Container eingesetzt werden. Nutzt man AutoFac, ist dies recht einfach umzusetzen, da es sogenannte extension methods gibt, welche die Registrierungen vom \lstcode{IServiceCollection} Objekt auf den AutoFac ContainerBuilder übertragen.

Die letzte Komponente ist die \lstcode{Configure} Methode. Diese Methode dient dazu, die \gls{owin} Pipeline aufzubauen. Hierfür wird der Methode ein Objekt übergeben, welches das \lstcode{IApplicationBuilder} Interface implementiert. Dieses Interface ermöglicht den Zugriff auf das \lstcode{IServiceProvider} Interface, sowie das \lstcode{IFeatureCollection} Interface und das Properties Dictionary. Mit der \lstcode{Use} Methode kann neue Middleware in die Pipeline eingefügt werden. Für dieses Interface existieren viele extension methods, da die \lstcode{Use} Methode etwas umständlich zu benutzen ist. Wie in \mylineref{lst:startup.configure.cs}{useMiddleware} zu sehen ist, kann man auch die \lstcode{UseMiddleware<>} Methode nutzen, um eine selbstgeschriebene Middleware in Klassenform einzubinden. Viele Frameworks wie \zB \gls{mvc} Core nutzen extension methods, um den Entwicklern die Arbeit zu erleichtern (\mylineref{lst:startup.configure.cs}{useMvc}). Bei der Konfiguration der Pipeline ist darauf zu achten, dass die Reihenfolge eine Rolle spielt. Die Middleware, welche als Erstes hinzugefügt wurde, wird auch immer von jedem Request als Erstes durchlaufen.

\file{startup.configure.cs}{Die Configure Methode des EventManager Systems.}{nc_csharp}

\Subsubsection{MVC Core}
Möchte man eine Web \gls{api} erstellen, welche dem \gls{rest} Prinzip folgt, so benötigt man eine Möglichkeit die verschiedenen URLs mit ihren jeweiligen Funktionen zu verbinden. Dies geschieht bei \gls{asp} mithilfe von \gls{mvc}. Um \gls{mvc} verwenden zu können, müssen zuerst in der \lstcode{ConfigureServices} Methode die notwendigen \gls{mvc} Klassen registriert werden. Hierfür wird, wie in \myautoref{lst:regMvc.cs} zu sehen ist, die Methode \lstcode{AddMvc} genutzt. \gls{mvc} ermöglicht es, bei der Registrierung zusätzliche Optionen anzugeben. Diese werden im Falle des EventManagers dazu benutzt, alle Routen als schützenswert anzusehen. Das bedeutet, der Client muss sich authentifiziert haben, bevor er Daten von der \gls{api} bekommt. Es ist möglich, diese Einschränkung mit dem Attribut \lstcode{[AllowAnonymous]} zu überschreiben.

\file{regMvc.cs}{Registrierung der MVC Klassen auf dem IServiceCollection Objekt.}{nc_csharp}

Sind alle notwendigen Klassen registriert, wird wie in \mylineref{lst:startup.configure.cs}{useMvc}, die \gls{mvc} Middleware in die \gls{owin} Pipeline eingebunden. Dies sollte nach der Authentifizierungsmiddleware geschehen, da sonst keine Möglichkeit besteht, ein Authentifizierungstoken zu überprüfen.

Nach den Konventionen von \gls{mvc} Core werden alle Klassen, die sich im Projektordner \enquote{Controllers} befinden und von der \lstcode{Controller} Klasse erben, als Controller erkannt. Für die Zuordnung einer konkreten Route und einer Methode gibt es mehrere Möglichkeiten. Werden keine weiteren Attribute angegeben, ergibt sich die Route aus dem Klassennamen, gefolgt von dem Methodennamen, \zB \lstcode{/ServiceTypes/CreateServiceAttributeSpecification}.

Da dies nicht sehr flexibel ist, werden im EventManager Attribute eingesetzt, damit alle Routen mit \lstcode{/api} anfangen, sowie um Id Parameter in die URL einbauen zu können. Ein Beispiel wäre \myautoref{lst:serviceTypesControllerRest.cs}, hier ist zu sehen, dass die Klasse ein \lstcode{[Route]} Attribut besitzt, welches den Anfang der Route als \lstcode{/api} festlegt. Ferner können Makros gesetzt werden. So wird, wenn die Route \lstcode{[controller]} enthält, der Name des Controllers eingesetzt.

Bei der Methode gibt es kein extra \lstcode{[Route]} Attribut. Das liegt daran, dass bereits ein Attribut benötigt wird, um das \gls{http}-Verb zu spezifizieren. In diesem Falle handelt es sich um das \lstcode{[HttpPut]} Attribut. Diesem wird ein String übergeben, welcher die Route bestimmt. Wie in \mylineref{lst:serviceTypesControllerRest.cs}{httpPut}, zu sehen ist, wird zuerst ein Argument in geschweiften Klammern angegeben. Dies bedeutet, dass \gls{asp} an dieser Stelle in der URL einen Integer erwartet. Dieser wird dann in einer Variable namens \enquote{typeId} an die Methode übergeben. In diesem Fall wäre also eine mögliche Route \lstcode{/api/ServiceTypes/1/spec}.

\label{nullParam}
Gerade im Falle eines Put oder auch Posts müssen dem Webserver Daten übergeben werden, die dieser abspeichern soll. Eine Möglichkeit ist, wie bereits erwähnt, Integer via URL Parameter zu übergeben. Es ist jedoch auch möglich, Daten aus dem \gls{http}-Body auszulesen. Hierfür muss der Methoden Parameter lediglich mit dem \lstcode{[FromBody]} Attribut ausgezeichnet werden. Befinden sich im \gls{http}-Body Daten, welche mittels eines \gls{json} Parsers in ein Objekt vom Typ des Methodenparameters umgewandelt werden können, wird das \gls{asp} Framework dies für den Entwickler übernehmen. Ist eine Umwandlung nicht möglich, wird \lstcode{NULL} übergeben.

\file{serviceTypesControllerRest.cs}{Auszug aus der ServiceTypesController Klasse.}{nc_csharp}

\Subsubsection{JWT Bearer Token} \label{jwt}
Um Clients zu authentifizieren nutzt der EventManager \gls{jwt}. Damit wird es möglich, den Authentifizierungsserver vom Datenserver zu trennen. Dies wird im Moment nicht praktiziert, ist aber als Erweiterung angedacht. Ebenso wie der Rest des Rechtesystems basieren \gls{jwt} Tokens auf Claims. Sowohl \gls{asp} als auch Angular bieten Funktionalitäten, um \gls{jwt} Tokens zu unterstützen.
