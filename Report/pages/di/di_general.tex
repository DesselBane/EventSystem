% !TEX root=../../report.tex

\Section[di_general]{Dependency Injection}

Dependency Injection beschäftigt sich mit dem Problem der Abhängigkeitsverwaltung. Möchte \zB eine Controller Klasse Datensätze aus der Datenbank abrufen, muss sie eine Referenz auf ein \lstcode{DbContext} Objekt haben oder bekommen können. Dieses Problem kann auf unterschiedliche Art und Weise gelöst werden. Bekannte Methoden sind die \enquote{Factory Method}, \enquote{Abstract Factory} oder der \enquote{Service Locator}. Alle diese Methoden haben aber das Problem, dass sie neue Abhängigkeiten schaffen. So muss \zB bei der \enquote{Abstract Factory} das konkrete Factory Objekt referenziert werden. Gleichzeitig werden die Abhängigkeiten der eigentlichen Klasse verschleiert, da sie nun mithilfe dieser Techniken abstrahiert wurden. \gls{di} nutzt das \enquote{Inversion of Control} Prinzip, um Abhängigkeiten offen zu deklarieren und gleichzeitig Abhängigkeiten auf Drittklassen zu vermeiden \cite{inversionOfControl} \cite{di}.

Bei \gls{di} werden die Abhängigkeiten im Konstruktor deklariert und die Klasse gibt die Kontrolle über die Herkunft der Abhängigkeiten ab. Diese Abgabe der Kontrolle wird als \enquote{Inversion of Control} bezeichnet. Um nun das Problem zu lösen, \dahe die Abhängigkeiten injiziert zu bekommen, wird eine weitere Komponente benötigt. Diese Komponente ist der sogennante \enquote{Container}. In einem Container werden zuerst alle Typen registriert, welche auffindbar sein sollen. Für eine Registrierung muss angegeben werden, welcher Typ injiziert werden soll, wenn nach einem bestimmten Typ gesucht wird. Somit kann man auch nach Interfaces sowie abstrakten oder auch nicht abstrakten Basisklassen suchen. Es kann angegeben werden, wie das spezifizierte Objekt erstellt werden soll. Jede Registrierung spezifiziert auch eine Objektlebensdauer. Hiermit lässt sich steuern, ob und in welchem Rahmen Objekte erstellt werden sollen. Standardmäßig wird jedes Mal, wenn ein Typ angefordert wird, ein neues Objekt dieses Typs erstellt.

Ein wichtiger Begriff in diesem Zusammenhang ist der des \enquote{Composition Root} \cite{compRoot}. Hierbei hanldet es sich um ein Pattern, welches spezifiziert wann und wo ein Container erstellt, die Registrierungen durchgeführt, sowie der Objektgraph erstellt werden. Das Pattern besagt, dass all dies so früh wie möglich im Applikationslebenszyklus passieren sollte. Im Falle von \gls{asp} geschieht dies in der \lstcode{Startup} Klasse und wird auch so vom \gls{asp} Framework vorgegeben (siehe \myref{sec:asp_basics}). Es ist sinnvoll, den Registrierungs-Code in einer einzigen Datei zu halten, da das Projekt sonst sehr schnell sehr unübersichtlich wird. Auch besagt das Pattern, dass nur Anwendungen ein Composition Root haben dürfen, nicht aber Frameworks, weil ein Framework keinen Lebenszyklus besitzt, sondern nur eine Ansammlung von Funktionalitäten sein sollte. Frameworks wie \gls{mvc} Core, welche für die Nutzung mit einem \gls{di} Framework entwickelt wurden, bieten oft extension methods an, um ihre Klassen zu registrieren.
